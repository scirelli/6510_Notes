<HTML><HEAD><TITLE>All_About_Your_1581-Online-Help Version 0.13</TITLE></HEAD>
<BODY><PRE>

  +------------------------------------------------------------------------
  |
  |      DISK-DRIVE 1581: ROM-LISTING
  |
  +------------------------------------------------------------------------
  |
  | Comments done by Peter Steiner, used with permission.
  |
  |   <A HREF="RO818000.HTM">$8000/32768</A>      Checksumme
  |   <A HREF="RO818004.HTM">$8004/32772</A>      Befehlsstring vom Computer auswerten ($c146)
  |   <A HREF="RO81804C.HTM">$804C/32844</A>      Abschluss eines Befehls ($c194)
  |   <A HREF="RO818071.HTM">$8071/32881</A>      INPUT-Puffer loeschen ($c1bd)
  |   <A HREF="RO81807C.HTM">$807C/32892</A>      Fehler ausgeben mit T&amp;S = 00 ($c1c8)
  |   <A HREF="RO818085.HTM">$8085/32901</A>      Sucht Drivenummer in der Befehlszeile ($c1d1)
  |   <A HREF="RO818099.HTM">$8099/32921</A>      Eingabezeile bis zum ':' auswerten ($c1e5)
  |   <A HREF="RO8180A2.HTM">$80A2/32930</A>      Eingabezeile pruefen bei Copy, Rename, New ($c1ee)
  |   <A HREF="RO81811C.HTM">$811C/33052</A>      Eingabezeile bis zu einem bestimmten Zeichen auswerten ($c268)
  |   <A HREF="RO818165.HTM">$8165/33125</A>      Kommandozeilenende feststellen (CR (/LF) entfernen) ($c2b3)
  |   <A HREF="RO8181E5.HTM">$81E5/33253</A>      LED-Routinen ($c100)
  |   <A HREF="RO8181FD.HTM">$81FD/33277</A>      Laufwerksnummer holen und setzen ($c312)
  |   <A HREF="RO81820B.HTM">$820B/33291</A>      Alle Parameter auf Laufwerksnummer pruefen und diese ggf. loeschen ($c320)
  |   <A HREF="RO818224.HTM">$8224/33316</A>      Laufwerksnummer testen und entfernen ($c33c)
  |   <A HREF="RO818251.HTM">$8251/33361</A>      Drivenummer setzen, LED einschalten ($c368)
  |   <A HREF="RO818270.HTM">$8270/33392</A>      Dateityp feststellen ('s,p,u,r,c') (z.B. '$*=s') ($c398)
  |   <A HREF="RO818295.HTM">$8295/33429</A>      Laufwerksnummer pruefen ($c3bd)
  |   <A HREF="RO8182A2.HTM">$82A2/33442</A>      Drive initialisieren, LED einschalten ($c3ca)
  |   <A HREF="RO8182B9.HTM">$82B9/33465</A>      alle angegebenen Dateien im Directory suchen ($c44f)
  |   <A HREF="RO8182E6.HTM">$82E6/33510</A>      Dateien einzeln suchen ($c48b)
  |   <A HREF="RO818327.HTM">$8327/33575</A>      Eintrag im Directory mit gesuchten Eintraegen vergleichen ($c4d8)
  |   <A HREF="RO8183D7.HTM">$83D7/33751</A>      Prueft, ob alle Dateien gefunden worden sind ($c617)
  |   <A HREF="RO8183FA.HTM">$83FA/33786</A>      1581: Zeichen hinter '*' vergleichen
  |   <A HREF="RO818424.HTM">$8424/33828</A>      naechsten Eintrag im Directory suchen : ($c5ac)
  |   <A HREF="RO8184AE.HTM">$84AE/33966</A>      Testet auf Diskettenwechsel und initialisiert ggf. ($c63d)
  |   <A HREF="RO8184EE.HTM">$84EE/34030</A>      Parameter aus dem INPUT-Puffer in Disk-Puffer kopieren ($c66e)
  |   <A HREF="RO818526.HTM">$8526/34086</A>      Laenge eines Parameters ermitteln ($c6a6)
  |   <A HREF="RO81854D.HTM">$854D/34125</A>      Directory-Zeile im Zwischenpuffer erzeugen ($c6ce)
  |   <A HREF="RO818688.HTM">$8688/34440</A>      Scratch ($c823)
  |   <A HREF="RO818746.HTM">$8746/34630</A>      Partition formatieren
  |   <A HREF="RO81876E.HTM">$876E/34670</A>      Copy ($c8f0)
  |   <A HREF="RO818841.HTM">$8841/34881</A>      aktuelles File oeffnen ($c9fa)
  |   <A HREF="RO818876.HTM">$8876/34934</A>      Byte aus aktueller Datei holen und auf Dateiende pruefen ($ca35)
  |   <A HREF="RO818895.HTM">$8895/34965</A>      REL-File zum Kopieren vorbereiten ($ca53)
  |   <A HREF="RO8188C5.HTM">$88C5/35013</A>      RENAME ($ca88)
  |   <A HREF="RO818903.HTM">$8903/35075</A>      aktuellen Filetyp ermitteln und
  |   <A HREF="RO81891E.HTM">$891E/35102</A>      pruefen, ob alle Files vor dem '=' nicht existieren
  |   <A HREF="RO81892F.HTM">$892F/35119</A>      Memory-Befehle ($caf8)
  |   <A HREF="RO81898F.HTM">$898F/35215</A>      User-Befehle ($cb5c)
  |   <A HREF="RO8189E4.HTM">$89E4/35300</A>      '#', oeffnen eines Direktzugriffkanals ($cb84)
  |   <A HREF="RO818A5D.HTM">$8A5D/35421</A>      Block-Befehle ($cc1b)
  |   <A HREF="RO818A9F.HTM">$8A9F/35487</A>      Parameter der Block-Befehle holen ($cc7c)
  |   <A HREF="RO818AD0.HTM">$8AD0/35536</A>      ASCII-Werte aus dem Input-Puffer in HEX-Werte umwandeln
  |   <A HREF="RO818B23.HTM">$8B23/35619</A>      Block-Free ($ccf5)
  |   <A HREF="RO818B2F.HTM">$8B2F/35631</A>      Block-Allocate ($cd03)
  |   <A HREF="RO818B65.HTM">$8B65/35685</A>      Block-Read-Parameter pruefen und Block lesen ($cd36)
  |   <A HREF="RO818B6B.HTM">$8B6B/35691</A>      Byte aus Puffer holen ($cd3c)
  |   <A HREF="RO818B71.HTM">$8B71/35697</A>      Block lesen und Pufferzeiger setzen ($cd42)
  |   <A HREF="RO818B85.HTM">$8B85/35717</A>      Block-Read ($cd56)
  |   <A HREF="RO818B8E.HTM">$8B8E/35726</A>      Super-Read
  |   <A HREF="RO818B9A.HTM">$8B9A/35738</A>      u1 ($cd5f)
  |   <A HREF="RO818BAE.HTM">$8BAE/35758</A>      Block-Write ($cd73)
  |   <A HREF="RO818BD1.HTM">$8BD1/35793</A>      Super-Write
  |   <A HREF="RO818BD7.HTM">$8BD7/35799</A>      u2 ($cd97)
  |   <A HREF="RO818BE3.HTM">$8BE3/35811</A>      Block-Execute ($cda3)
  |   <A HREF="RO818BFA.HTM">$8BFA/35834</A>      Block-Pointer ($cdbd)
  |   <A HREF="RO818C0F.HTM">$8C0F/35855</A>      Kanal oeffnen ($cdd2)
  |   <A HREF="RO818C2F.HTM">$8C2F/35887</A>      Kanal oeffnen, Blockparameter holen und testen ($cdf2)
  |   <A HREF="RO818C44.HTM">$8C44/35908</A>      Kanal oeffnen, Blockparameter holen und NICHT testen
  |   <A HREF="RO818C5C.HTM">$8C5C/35932</A>      Puffer allokieren
  |   <A HREF="RO818C61.HTM">$8C61/35937</A>      Block-Befehle und Adressen ($cc5d)
  |   <A HREF="RO818C89.HTM">$8C89/35977</A>      Position des Records berechnen ($ce0e)
  |   <A HREF="RO818CC1.HTM">$8CC1/36033</A>      Zahl der Bytes bis zum gesuchten Record berechnen ($ce2c)
  |   <A HREF="RO818CE6.HTM">$8CE6/36070</A>      24*8-Bit-Multiplikationsroutine ($ce4e)
  |   <A HREF="RO818D06.HTM">$8D06/36102</A>      24/8-Bit-Divisionsroutine ($ce71)
  |   <A HREF="RO818D38.HTM">$8D38/36152</A>      Rechenregister 1 loeschen ($ced9)
  |   <A HREF="RO818D41.HTM">$8D41/36161</A>      Rechenregister 2 *2 bzw. *4 ($cee2)
  |   <A HREF="RO818D4C.HTM">$8D4C/36172</A>      Rechenregister addieren ($ceed)
  |   <A HREF="RO818D59.HTM">$8D59/36185</A>      Feststellen, welcher Kanal schon am laengsten inaktiv ist
  |   <A HREF="RO818D7D.HTM">$8D7D/36221</A>      Puffer wechseln im Zwei-Puffer-Betrieb ($cf1e)
  |   <A HREF="RO818E37.HTM">$8E37/36407</A>      Falls dem Kanal ein Puffer fehlt, einen neuen zuordnen ($cf7b)
  |   <A HREF="RO818E4D.HTM">$8E4D/36429</A>      Aktiven Puffer wechseln ($cf8c)
  |   <A HREF="RO818E5C.HTM">$8E5C/36444</A>      Byte ueber internen Schreibkanal in Puffer schreiben ($cf9b)
  |   <A HREF="RO818E78.HTM">$8E78/36472</A>      Byte in aktuelle Datei schreiben ($cfb7)
  |   <A HREF="RO818EB1.HTM">$8EB1/36529</A>      Byte in Puffer schreiben, Pufferzeiger erhoehen ($cff1)
  |   <A HREF="RO818EC5.HTM">$8EC5/36549</A>      Initialize ($d005)
  |   <A HREF="RO818EDC.HTM">$8EDC/36572</A>      Blockheader des Verzeichnisheaders suchen
  |   <A HREF="RO818F03.HTM">$8F03/36611</A>      Partition initialisieren ($d042)
  |   <A HREF="RO818FD6.HTM">$8FD6/36822</A>      Block einlesen und Folgeblock merken ($d09b)
  |   <A HREF="RO818FEA.HTM">$8FEA/36842</A>      Block (und ggf. Folgeblock) im 2-Puffer-Modus lesen ($d0af)
  |   <A HREF="RO818FFE.HTM">$8FFE/36862</A>      ???
  |   <A HREF="RO819027.HTM">$9027/36903</A>      Kanal zum Lesen holen und pruefen ($d0eb)
  |   <A HREF="RO819042.HTM">$9042/36930</A>      Kanal zum Schreiben holen und pruefen ($d107)
  |   <A HREF="RO81905F.HTM">$905F/36959</A>      Aktuellen Filetyp holen ($d125)
  |   <A HREF="RO819069.HTM">$9069/36969</A>      Kanal- und Puffernummer holen ($d12f)
  |   <A HREF="RO819071.HTM">$9071/36977</A>      Byte aus aktuellem Puffer holen ($d137)
  |   <A HREF="RO81909B.HTM">$909B/37019</A>      Byte aus aktueller Datei holen ($d156)
  |   <A HREF="RO819112.HTM">$9112/37138</A>      Schreiben eines Bytes in eine Datei im 2-Puffer Modus. ($d19d)
  |   <A HREF="RO819138.HTM">$9138/37176</A>      Erhoehen des aktuellen Pufferzeigers ($d1c6)
  |   <A HREF="RO819145.HTM">$9145/37189</A>      Autoboot bei Warmstart ein/aus
  |   <A HREF="RO819157.HTM">$9157/37207</A>      Kanal oeffnen und entsprechende Zahl Puffer zuordnen ($d1df)
  |   <A HREF="RO81919E.HTM">$919E/37278</A>      Freigeben einer SA ausser der des Kommandokanals; Puffer freigeben ($d227)
  |   <A HREF="RO8191CE.HTM">$91CE/37326</A>      Puffer und dessen Kanalzuordnung freigeben ($d25a)
  |   <A HREF="RO819204.HTM">$9204/37380</A>      Suchen eines freien oder inaktiven Puffers ($d28e)
  |   <A HREF="RO819228.HTM">$9228/37416</A>      Suchen und belegen eines freien Puffers ($d2ba)
  |   <A HREF="RO81923E.HTM">$923E/37438</A>      einen inaktiven Puffer eines Kanals freigeben ($d2da)
  |   <A HREF="RO819252.HTM">$9252/37458</A>      Puffer freigeben                &lt;-- Einsprung
  |   <A HREF="RO819262.HTM">$9262/37474</A>      Kanaele der Sekundaeradressen 1-14 freigeben ($d307)
  |   <A HREF="RO81926E.HTM">$926E/37486</A>      Die SA 0-14 des Laufwerks 0 freigeben
  |   <A HREF="RO819291.HTM">$9291/37521</A>      'Stehlen' eines inaktiven Puffers ($d339)
  |   <A HREF="RO8192DB.HTM">$92DB/37595</A>      Freien Kanal suchen ($d37f)
  |   <A HREF="RO8192F4.HTM">$92F4/37620</A>      Byte fuer beliebige SA holen ($d39b)
  |   <A HREF="RO819303.HTM">$9303/37635</A>      Byte aus beliebigem Kanal holen ($d3aa)
  |   <A HREF="RO819370.HTM">$9370/37744</A>      Fehlerkanal auslesen bzw M-R-Befehl ($d414)
  |   <A HREF="RO8193AA.HTM">$93AA/37802</A>      Lesen des naechsten Blocks ($d44d)
  |   <A HREF="RO8193BD.HTM">$93BD/37821</A>      Lesen/Schreiben des aktuellen Puffers ($d460)
  |   <A HREF="RO8193CF.HTM">$93CF/37839</A>      Datei auf internem Lesekanal oeffnen,
  |   <A HREF="RO8193E0.HTM">$93E0/37856</A>      Datei auf internem Schreibkanal oeffnen,
  |   <A HREF="RO8193E7.HTM">$93E7/37863</A>      Neuen Block an das Directory anhaengen ($d48d)
  |   <A HREF="RO819422.HTM">$9422/37922</A>      Pufferzeiger auf bestimmten Wert setzen ($d4c8)
  |   <A HREF="RO819434.HTM">$9434/37940</A>      interne Schreib-/Lesekanaele freigeben ($d4da)
  |   <A HREF="RO819450.HTM">$9450/37968</A>      Holt Byte aus aktuellem Puffer ($d4f6)
  |   <A HREF="RO819460.HTM">$9460/37984</A>      Prueft auf Diskettenwechsel
  |   <A HREF="RO819471.HTM">$9471/38001</A>      T&amp;S auf Gueltigkeit pruefen       ($d506)
  |   <A HREF="RO8194A8.HTM">$94A8/38056</A>      Track und Sektor aus Jobpuffer holen und als aktuelle T&amp;S merken ($d552)
  |   <A HREF="RO8194B5.HTM">$94B5/38069</A>      Auf gueltigen Block (T&amp;S) pruefen ($d55f)
  |   <A HREF="RO8194CB.HTM">$94CB/38091</A>      Meldung fuer falsches Formatkennzeichen ausgeben ($d572)
  |   <A HREF="RO8194D3.HTM">$94D3/38099</A>      Job setzen und Controller aufrufen ($d57a)
  |   <A HREF="RO8194DE.HTM">$94DE/38110</A>      Schreib-/Lesejobs pruefen und Durchfuehrung abwarten ($d586)
  |   <A HREF="RO8194F8.HTM">$94F8/38136</A>      Job auf fehlerfreie Durchfuehrung pruefen ($d5a6)
  |   <A HREF="RO819585.HTM">$9585/38277</A>      T&amp;S an DC uebergeben ($d6d0)
  |   <A HREF="RO819598.HTM">$9598/38296</A>      Aufruf des Controllers
  |   <A HREF="RO8195AB.HTM">$95AB/38315</A>      Neue Datei im Directory eintragen ($d6e4)
  |   <A HREF="RO819678.HTM">$9678/38520</A>      Datei mit SA 0-14 oeffnen ($d7b4)
  |   <A HREF="RO819773.HTM">$9773/38771</A>      File zum Schreiben oeffnen ($d8c6)
  |   <A HREF="RO8197A2.HTM">$97A2/38818</A>      Oeffnen eines Files mit Ueberschreiben ($d8f5)
  |   <A HREF="RO8197ED.HTM">$97ED/38893</A>      Zugriffsart feststellen und File zum Lesen oeffnen ($d940)
  |   <A HREF="RO81984D.HTM">$984D/38989</A>      Oeffnen eines Files zum Lesen ($d9a0)
  |   <A HREF="RO819890.HTM">$9890/39056</A>      neues File anlegen und zum Schreiben oeffnen ($d9e3)
  |   <A HREF="RO819896.HTM">$9896/39062</A>      T&amp;S eines Files holen und fuer 'LOAD &quot;*&quot;,8' merken ($d9ef)
  |   <A HREF="RO8198AB.HTM">$98AB/39083</A>      File-Modus oder File-Typ aus Kommandozeile holen ($da09)
  |   <A HREF="RO8198CC.HTM">$98CC/39116</A>      APPEND: Fileende suchen und auf Schreiben umschalten ($da2a)
  |   <A HREF="RO8198F7.HTM">$98F7/39159</A>      Oeffnen des Directory als Basicprogramm ($da55)
  |   <A HREF="RO81995C.HTM">$995C/39260</A>      CLOSE-Routine: aktuelle Sekundaeradresse schliessen ($dac0)
  |   <A HREF="RO819986.HTM">$9986/39302</A>      Alle Dateien schliessen ($daec)
  |   <A HREF="RO81999F.HTM">$999F/39327</A>      Datei schliessen ($db02)
  |   <A HREF="RO819A2A.HTM">$9A2A/39466</A>      letzten Dateiblock abspeichern ($db62)
  |   <A HREF="RO819A72.HTM">$9A72/39538</A>      Eintrag im Directory nach dem Schreiben updaten ($dba5)
  |   <A HREF="RO819B0D.HTM">$9B0D/39693</A>      Kanal zum Lesen suchen
  |   <A HREF="RO819B9B.HTM">$9B9B/39835</A>      Pufferzeiger initialisieren ($dcb6)
  |   <A HREF="RO819BC3.HTM">$9BC3/39875</A>      File zum Schreiben oeffnen ($dcda)
  |   <A HREF="RO819CCA.HTM">$9CCA/40138</A>      Byte in aktuellen Side-Sektor schreiben ($dd8d)
  |   <A HREF="RO819CD3.HTM">$9CD3/40147</A>      Dateistatus setzen/loeschen ($dd95)
  |   <A HREF="RO819CE9.HTM">$9CE9/40169</A>      Prueft den Jobcode des aktuellen Puffers auf 'Schreiben' ($ddab)
  |   <A HREF="RO819CF5.HTM">$9CF5/40181</A>      prueft, ob gesuchtes File durch eine SA angesprochen wird ($ddb7)
  |   <A HREF="RO819D2E.HTM">$9D2E/40238</A>      Puffer schreiben, wenn er veraendert wurde ($ddf1)
  |   <A HREF="RO819D3A.HTM">$9D3A/40250</A>      Folgeblock im aktuellen Block eintragen ($ddfd)
  |   <A HREF="RO819D49.HTM">$9D49/40265</A>      T&amp;S des Folgeblocks holen ($de0c)
  |   <A HREF="RO819D56.HTM">$9D56/40278</A>      Blocklaenge des letzten Datenblocks setzen ($de19)
  |   <A HREF="RO819D69.HTM">$9D69/40297</A>      Zeiger auf Anfang des aktiven Puffers setzen ($de2b)
  |   <A HREF="RO819D79.HTM">$9D79/40313</A>      T&amp;S der aktuellen Datei holen ($de3b)
  |   <A HREF="RO819D8E.HTM">$9D8E/40334</A>      Schreib-Lesejobs aufrufen ($de50)
  |   <A HREF="RO819DCE.HTM">$9DCE/40398</A>      T&amp;S des Folgeblocks des aktiven Kanals holen
  |   <A HREF="RO819DDE.HTM">$9DDE/40414</A>      Pufferinhalte kopieren ($dea5)
  |   <A HREF="RO819DFA.HTM">$9DFA/40442</A>      Puffer mit $00 fuellen ($dec1)
  |   <A HREF="RO819E0B.HTM">$9E0B/40459</A>      Nummer des aktuellen Side-Sektors holen ($ded2)
  |   <A HREF="RO819E15.HTM">$9E15/40469</A>      Side-Sektor-Pufferzeiger auf beliebigen Wert setzen ($dedc)
  |   <A HREF="RO819E23.HTM">$9E23/40483</A>      Pufferzeiger des aktuellen Side-Sektors auf beliebigen
  |   <A HREF="RO819E32.HTM">$9E32/40498</A>      Gruppe anwaehlen, ggf. Side-Sektor laden ($def8)
  |   <A HREF="RO819E56.HTM">$9E56/40534</A>      Side-Sektor lesen/schreiben ($df1b)
  |   <A HREF="RO819E75.HTM">$9E75/40565</A>      Pufferzeiger des Side-Sektors nach $64-$65 holen ($df45)
  |   <A HREF="RO819E7D.HTM">$9E7D/40573</A>      Anzahl der benoetigten Blocks einer REL-Datei berechnen ($df4c)
  |   <A HREF="RO819E97.HTM">$9E97/40599</A>      Anzahl der benoetigten Blocks einer REL-Datei berechnen
  |   <A HREF="RO819ED3.HTM">$9ED3/40659</A>      Feststellen, ob Record existiert und ggf. richtige Gruppe anwaehlen ($df66)
  |   <A HREF="RO819F11.HTM">$9F11/40721</A>      Nummer des aktiven Puffers holen ($df93)
  |   <A HREF="RO819F1C.HTM">$9F1C/40732</A>      Aktiven Puffer pruefen und holen ($df9e)
  |   <A HREF="RO819F33.HTM">$9F33/40755</A>      Pruefen, ob ein Puffer des Kanals nicht belegt ist ($dfb7)
  |   <A HREF="RO819F3E.HTM">$9F3E/40766</A>      einem Kanal einen neuen Puffer zuordnen ($dfc2)
  |   <A HREF="RO819F4C.HTM">$9F4C/40780</A>      naechsten Record holen ($dfd0)
  |   <A HREF="RO819FBF.HTM">$9FBF/40895</A>      ggf. alten Puffer speichern, dann Folgeblock(s) einlesen  ($e03c)
  |   <A HREF="RO819FFC.HTM">$9FFC/40956</A>      Ein Byte in Record-Puffer schreiben ($e07c)
  |   <A HREF="RO81A033.HTM">$A033/41011</A>      Empfangene Daten in Record schreiben ($e0ab)
  |   <A HREF="RO81A07B.HTM">$A07B/41083</A>      Rest eines Records mit $00 auffuellen ($e0f3)
  |   <A HREF="RO81A08D.HTM">$A08D/41101</A>      Flag fuer 'Puffer geaendert' setzen ($e105)
  |   <A HREF="RO81A09C.HTM">$A09C/41116</A>      Flag fuer 'Puffer geaendert' loeschen ($e115)
  |   <A HREF="RO81A0A6.HTM">$A0A6/41126</A>      Byte aus Record-Puffer holen ($e120)
  |   <A HREF="RO81A0E1.HTM">$A0E1/41185</A>      Naechsten Record lesen ($e153)
  |   <A HREF="RO81A0EC.HTM">$A0EC/41196</A>      Abbruch bei Fehler ($e15e)
  |   <A HREF="RO81A0FD.HTM">$A0FD/41213</A>      Letztes benutzte Zeichen im Record suchen ($e16e)
  |   <A HREF="RO81A15C.HTM">$A15C/41308</A>      Letzten Datenblock einer REL-Datei
  |   <A HREF="RO81A1A1.HTM">$A1A1/41377</A>      Position-Befehl ($e207)
  |   <A HREF="RO81A20D.HTM">$A20D/41485</A>      gesuchten Record zur Ausgabe bereitstellen ($e275)
  |   <A HREF="RO81A235.HTM">$A235/41525</A>      benoetigte Datenbloecke  ggf. einlesen ($e29c)
  |   <A HREF="RO81A298.HTM">$A298/41624</A>      Puffer mit leeren Records fuellen ($e2e2)
  |   <A HREF="RO81A2BC.HTM">$A2BC/41660</A>      Position des naechsten Records berechnen ($e304)
  |   <A HREF="RO81A2D6.HTM">$A2D6/41686</A>      Bloecke zu REL-File hinzufuegen ($e31c)
  |   <A HREF="RO81A438.HTM">$A438/42040</A>      Parameter des letzten Records der Datei merken
  |   <A HREF="RO81A459.HTM">$A459/42073</A>      Neuen Side-Sektor zur relativen Datei hinzufuegen ($e31c)
  |   <A HREF="RO81A547.HTM">$A547/42311</A>      Wenn Gruppe voll, dann neue Gruppe anlegen
  |   <A HREF="RO81A56E.HTM">$A56E/42350</A>      Prueft, ob Super-Side-Sektoren verwendet werden, oder nicht
  |   <A HREF="RO81A574.HTM">$A574/42356</A>      Super-Side-Sektor laden
  |   <A HREF="RO81A5A9.HTM">$A5A9/42409</A>      letzte existierende Gruppe ermitteln
  |   <A HREF="RO81A5C0.HTM">$A5C0/42432</A>      Gruppe anwaehlen
  |   <A HREF="RO81A602.HTM">$A602/42498</A>      Fehlermeldungen ($e4fc)
  |   <A HREF="RO81A7AE.HTM">$A7AE/42926</A>      Error-Routine des Controllers ($e60a)
  |   <A HREF="RO81A7F1.HTM">$A7F1/42993</A>      CmdError: Error-Routine des DOS ($e645)
  |   <A HREF="RO81A83E.HTM">$A83E/43070</A>      Byte in Ziffernstring umwandeln ($e69b)
  |   <A HREF="RO81A862.HTM">$A862/43106</A>      Fehlermeldung bereitstellen ($e6bc)
  |   <A HREF="RO81A8AD.HTM">$A8AD/43181</A>      Fehlertext in Puffer schreiben ($e706)
  |   <A HREF="RO81A926.HTM">$A926/43302</A>      Autoboot-Routine
  |   <A HREF="RO81A938.HTM">$A938/43320</A>      JCBMBOOT: Autoboot-Programm aufrufen
  |   <A HREF="RO81A94C.HTM">$A94C/43340</A>      JCBMBOOTRTN: Ruecksprung aus Autoboot-Programm
  |   <A HREF="RO81A956.HTM">$A956/43350</A>      Utility-Loader (&amp;) ($e7a3)
  |   <A HREF="RO81AA0F.HTM">$AA0F/43535</A>      Sprungadressen der Error-Routinen merken
  |   <A HREF="RO81AA27.HTM">$AA27/43559</A>      Sektorversatz einstellen
  |   <A HREF="RO81AA2D.HTM">$AA2D/43565</A>      Anzahl Leseversuche einstellen
  |   <A HREF="RO81AA33.HTM">$AA33/43571</A>      Cache-Verzoegerung einstellen
  |   <A HREF="RO81AA39.HTM">$AA39/43577</A>      ROM-Test
  |   <A HREF="RO81AA3C.HTM">$AA3C/43580</A>      Burst-Befehl $1e: CHGUTL (bei der 1571: $8fe5)
  |   <A HREF="RO81AAA8.HTM">$AAA8/43688</A>      Burst-Memory-Read/Write
  |   <A HREF="RO81AB09.HTM">$AB09/43785</A>      Parameter '0' und '1' auswerten (CHGUTL-Parameter)
  |   <A HREF="RO81AB1D.HTM">$AB1D/43805</A>      ROM-Signatur pruefen (CRC-Test) (bei der 1571: $924e)
  |
  |    BUS-Routinen
  |    [Ein grosses Problem bei der Kommentierung der Bus-Routinen ist, dass die
  |     Leitungen zwischen dem Computer und den Laufwerken low-aktiv sind und
  |     im Computer sogar die Eingangs-Signale nicht wieder zurueckgekippt werden.
  |     Zwischen den verschiedenen ROM-Listings gehen daher die Meinungen
  |     auseiander, was nun unter einem High- und einem Low-Signal zu verstehen
  |     ist. Weil selbst ein im Computer abgeschicktes Hi wieder als Lo empfangen
  |     wird, wird dort deshalb haeufig der am Bus messbare Pegel benutzt. Dagegen
  |     bezeichnen die mir bekannten DOS-Listings ein 1-Bit im Register als Hi
  |     (bei dem die entsprechende Bus-Leitung dann aber Lo ist), weil dann der
  |     'aktive' Pegel mit Hi bezeichnet wird. Wenn also die Ausgaberegister Lo
  |     sind, sind die entsprechenden Treiber inaktiv und stoeren andere Geraete
  |     nicht bei der Datenuebertragung. Das bedeutet aber auch, dass das DATA OUT-
  |     auf Lo gesetzt werden muss, wenn ein 1-Datenbit uebertragen werden soll.
  |     Ich habe mich bei der Kommentierung der BUS-Routinen an das System der
  |     mir bekannten DOS-Listings gehalten und bezeichne ein Signal als Hi, wenn
  |     das entsprechende Register-Bit 1 ist.]
  |
  |   <A HREF="RO81ABCF.HTM">$ABCF/43983</A>      ATN-bearbeiten ($e85b; bei der 1571: $80ce)
  |   <A HREF="RO81AC9D.HTM">$AC9D/44189</A>      FSM: DRF (Device Request Fast) Signal senden (bei der 1571: $8199)
  |   <A HREF="RO81ACB6.HTM">$ACB6/44214</A>      FSM auf Eingang schalten
  |   <A HREF="RO81ACCF.HTM">$ACCF/44239</A>      FSM auf Ausgabe schalten
  |   <A HREF="RO81ACE8.HTM">$ACE8/44264</A>      DATA OUT auf Lo (die Busleitung wird dadurch Hi)
  |   <A HREF="RO81ACF1.HTM">$ACF1/44273</A>      DATA OUT auf Hi (die Busleitung wird dadurch Lo)
  |   <A HREF="RO81ACFA.HTM">$ACFA/44282</A>      CLOCK OUT auf Hi (die Busleitung wird dadurch Lo)
  |   <A HREF="RO81AD03.HTM">$AD03/44291</A>      CLOCK OUT auf Lo (die Busleitung wird dadurch Hi)
  |   <A HREF="RO81AD0C.HTM">$AD0C/44300</A>      Bus auslesen und entprellen
  |   <A HREF="RO81AD15.HTM">$AD15/44309</A>      ATN-Modus testen ($ea59; bei der 1571: $ea59)
  |   <A HREF="RO81AD2F.HTM">$AD2F/44335</A>      Kurze Zeit warten (bei der 1571: $a47e)
  |   <A HREF="RO81AD3C.HTM">$AD3C/44348</A>      NMI-Routine ($ff01)
  |   <A HREF="RO81AD5C.HTM">$AD5C/44380</A>      Daten auf seriellen Bus ausgeben ($e909; bei der 1571: $823d)
  |   <A HREF="RO81AE42.HTM">$AE42/44610</A>      Byte vom seriellen Bus holen ($e9c9; bei der 1571: $82c7)
  |   <A HREF="RO81AEB8.HTM">$AEB8/44728</A>      Daten vom seriellem Bus holen ($ea2e; bei der 1571: $8342)
  |   <A HREF="RO81AED9.HTM">$AED9/44761</A>      Ende bei Uebertragungsfehler
  |   <A HREF="RO81AEDF.HTM">$AEDF/44767</A>      Busbetrieb beenden
  |   <A HREF="RO81AEEA.HTM">$AEEA/44778</A>      JSPINOUT: FSM-Datenrichtung festlegen
  |   <A HREF="RO81AEF2.HTM">$AEF2/44786</A>      Fehlerblinken nach Selbsttest ($ea6e)
  |   <A HREF="RO81AF24.HTM">$AF24/44836</A>      Reset-Routine ($eaa0)
  |   <A HREF="RO81AFCA.HTM">$AFCA/45002</A>      Warmstart ($eb22)
  |   <A HREF="RO81AFE9.HTM">$AFE9/45033</A>      Dos-Tabellen initialisieren ($eb3a)
  |   <A HREF="RO81B0B3.HTM">$B0B3/45235</A>      Ganze Diskette als Partition setzen
  |   <A HREF="RO81B0CF.HTM">$B0CF/45263</A>      Physikalisches 1581-Diskettenformat festlegen
  |   <A HREF="RO81B0F0.HTM">$B0F0/45296</A>      JIDLE - Hauptleerschleife ($ebe7)
  |   <A HREF="RO81B15B.HTM">$B15B/45403</A>      Cache am Ende der Verzoegerungszeit auf Diskette schreiben
  |   <A HREF="RO81B17C.HTM">$B17C/45436</A>      Directory formatieren und in Ausgabepuffer schreiben ($ec9e)
  |   <A HREF="RO81B237.HTM">$B237/45623</A>      Directoryzeile in Ausgabepuffer kopieren ($ed59)
  |   <A HREF="RO81B245.HTM">$B245/45637</A>      Byte aus Directory holen und zur Ausgabe bereitstellen ($ed67)
  |   <A HREF="RO81B262.HTM">$B262/45666</A>      Validate-Befehl ($ed84)
  |   <A HREF="RO81B2C7.HTM">$B2C7/45767</A>      Blocks eines Files in BAM belegen ($ede5)
  |   <A HREF="RO81B2EF.HTM">$B2EF/45807</A>      naechsten Block einer Partition holen
  |   <A HREF="RO81B323.HTM">$B323/45859</A>      Partition-Parameter aus Verzeichniseintrag holen
  |   <A HREF="RO81B33C.HTM">$B33C/45884</A>      Partition in Bam belegen
  |   <A HREF="RO81B348.HTM">$B348/45896</A>      NEW-Befehl ($ee0d)
  |   <A HREF="RO81B380.HTM">$B380/45952</A>      ???
  |   <A HREF="RO81B390.HTM">$B390/45968</A>      Verzeichnis-Header und BAM anlegen ($ee56)
  |   <A HREF="RO81B43D.HTM">$B43D/46141</A>      BAM-Puffer loeschen ($f005)
  |   <A HREF="RO81B44A.HTM">$B44A/46154</A>      neue BAM erzeugen ($eeb7)
  |   <A HREF="RO81B515.HTM">$B515/46357</A>      Wenn die BAM geaendert wurde, dann
  |   <A HREF="RO81B546.HTM">$B546/46406</A>      Block in Bam freigeben ($ef5f)
  |   <A HREF="RO81B572.HTM">$B572/46450</A>      Block in BAM belegen ($ef93)
  |   <A HREF="RO81B5B4.HTM">$B5B4/46516</A>      BAM-Zeiger auf Eintrag fuer aktuellen Track setzen ($f011)
  |   <A HREF="RO81B5D8.HTM">$B5D8/46552</A>      Pruefen, ob Block $4e im aktuellen Track frei ist ($efd2)
  |   <A HREF="RO81B5F2.HTM">$B5F2/46578</A>      Wenn BAM-Puffer leer, dann BAM einlesen ($f0df)
  |   <A HREF="RO81B612.HTM">$B612/46610</A>      BAM auf Diskette schreiben
  |   <A HREF="RO81B633.HTM">$B633/46643</A>      Verzeichnis-Header in aktuellen Puffer lesen, ggf. BAM lesen
  |   <A HREF="RO81B643.HTM">$B643/46659</A>      T&amp;S und Puffernummer eines Dir-Sektors an DC uebergeben
  |   <A HREF="RO81B64F.HTM">$B64F/46671</A>      BAM-Zeiger auf 1. BAM-Puffer setzen ($ef3a)
  |   <A HREF="RO81B65B.HTM">$B65B/46683</A>      Anzahl freier Blocks zur Ausgabe bereitstellen ($ef4d)
  |   <A HREF="RO81B668.HTM">$B668/46696</A>      Folgeblock fuer Datei suchen ($f11e)
  |   <A HREF="RO81B6ED.HTM">$B6ED/46829</A>      Startblock einer neuen Datei suchen ($f1a9)
  |   <A HREF="RO81B746.HTM">$B746/46918</A>      naechsten freien Block im aktuellen Track suchen ($f1fa)
  |   <A HREF="RO81B75E.HTM">$B75E/46942</A>      Prueft, ob im aktuellen Track die Anzahl freier Blocks stimmt. ($f220)
  |   <A HREF="RO81B781.HTM">$B781/46977</A>      Partition-Befehl
  |   <A HREF="RO81B811.HTM">$B811/47121</A>      Pruefen, ob alle Blocks der Partition vor dem Anlegen noch frei sind
  |   <A HREF="RO81B851.HTM">$B851/47185</A>      Partition-Namen holen
  |   <A HREF="RO81B85F.HTM">$B85F/47199</A>      Parameter fuer die Partitionerstellung holen
  |   <A HREF="RO81B88D.HTM">$B88D/47245</A>      Neuen Bereich anlegen
  |   <A HREF="RO81B8D2.HTM">$B8D2/47314</A>      Burst-Befehl $1f: Fastload (bei der 1571: $9080)
  |   <A HREF="RO81B9D3.HTM">$B9D3/47571</A>      ERROR: Controller-Error-Routine des Burst-Fastloads
  |   <A HREF="RO81B9DF.HTM">$B9DF/47583</A>      CMDERR: Fehler-Routine des Burst-Fastloads
  |   <A HREF="RO81B9EC.HTM">$B9EC/47596</A>      Fehlermeldung ausgeben (bei der 1571: $91ad)
  |   <A HREF="RO81B9FB.HTM">$B9FB/47611</A>      #$02 auf FSM-Bus ausgeben (File not found), TXA
  |   <A HREF="RO81BA06.HTM">$BA06/47622</A>      Filenamen nach Drivenummer durchsuchen
  |   <A HREF="RO81BA40.HTM">$BA40/47680</A>      Byte auf FSM-Bus ausgeben (bei der 1571: $9228)
  |   <A HREF="RO81BA64.HTM">$BA64/47716</A>      Fehlerbehandlung fuer Burst-Fastload setzen
  |   <A HREF="RO81BA7C.HTM">$BA7C/47740</A>      Sprungvektoren der Fehlerbehandlung retten
  |   <A HREF="RO81BA95.HTM">$BA95/47765</A>      Sprungvektoren der Fehlerbehandlung zurueckschreiben
  |   <A HREF="RO81BAAE.HTM">$BAAE/47790</A>      Burst-Befehl: Read mit logischen Blockangaben (bei der 1571: $83a4)
  |   <A HREF="RO81BAF7.HTM">$BAF7/47863</A>      Burst-Status uebermitteln (bei der 1571: $837c)
  |   <A HREF="RO81BAFC.HTM">$BAFC/47868</A>      Status in a setzen und uebermitteln (bei der 1571: $8381)
  |   <A HREF="RO81BB11.HTM">$BB11/47889</A>      Burst-Befehle $00,$10: Read (bei der 1571: $8371)
  |   <A HREF="RO81BB74.HTM">$BB74/47988</A>      Burst-Befehl: Write mit logischen Blockangaben
  |   <A HREF="RO81BBF6.HTM">$BBF6/48118</A>      Burststatus bei Schreibfehlern ausgeben
  |   <A HREF="RO81BC01.HTM">$BC01/48129</A>      Burst-Befehle $02,$12: Write (bei der 1571: $83ec)
  |   <A HREF="RO81BCB2.HTM">$BCB2/48306</A>      Burst-Befehle $04,$14: Inquire Disk (bei der 1571: $848b)
  |   <A HREF="RO81BD0A.HTM">$BD0A/48394</A>      ???
  |   <A HREF="RO81BD12.HTM">$BD12/48402</A>      Burst-Befehle $06,$07,$16,$17: Format (bei der 1571: $84b7)
  |   <A HREF="RO81BDFC.HTM">$BDFC/48636</A>      Burst-Befehle $08,$09: (n.v.) (bei der 1571: $85a5)
  |   <A HREF="RO81BE06.HTM">$BE06/48646</A>      Burst-Befehle $0a,$1a: Query Disk Format (bei der 1571: $8517)
  |   <A HREF="RO81BEBB.HTM">$BEBB/48827</A>      Burst-Befehl $0c: Inquire Status (bei der 1571: $856b)
  |   <A HREF="RO81BEF8.HTM">$BEF8/48888</A>      Burst-Befehle $0e,$0f: (n.v.)
  |   <A HREF="RO81BF02.HTM">$BF02/48898</A>      Burst-Befehle $1c,$1d: Dump Cache
  |   <A HREF="RO81BF44.HTM">$BF44/48964</A>      Kopf ggf. auf die angegebene Spur setzen (bei der 1571: $891b)
  |   <A HREF="RO81BF5A.HTM">$BF5A/48986</A>      Burst-Status senden, wenn gerade Daten vom Computer empfangen werden
  |   <A HREF="RO81BF66.HTM">$BF66/48998</A>      Burst-Status setzen
  |   <A HREF="RO81BF83.HTM">$BF83/49027</A>      FSM: Byte ausgeben (bei der 1571: $9228)
  |   <A HREF="RO81BFAB.HTM">$BFAB/49067</A>      Statusbyte ausgeben
  |   <A HREF="RO81BFB0.HTM">$BFB0/49072</A>      Job ausfuehren und ggf. bei Fehlern mehrmals versuchen (bei der 1571: $864b)
  |   <A HREF="RO81BFE3.HTM">$BFE3/49123</A>      Cachepuffer auf Diskette schreiben
  |   <A HREF="RO81C026.HTM">$C026/49190</A>      FSM: Wartet, bis naechstes Byte gesendet werden soll (bei der 1571: $86a0)
  |   <A HREF="RO81C040.HTM">$C040/49216</A>      physikalischen Folgesektor holen (bei der 1571: $886c)
  |   <A HREF="RO81C07A.HTM">$C07A/49274</A>      logischen Folgesektor holen (bei der 1571: $886c)
  |   <A HREF="RO81C097.HTM">$C097/49303</A>      Groesste/kleinste Sektornummer suchen (bei der 1571: $8961)
  |   <A HREF="RO81C0BE.HTM">$C0BE/49342</A>      JLCC: Controller-Routine
  |   <A HREF="RO81C163.HTM">$C163/49507</A>      Tabellen des Controller-Programms
  |   <A HREF="RO81C390.HTM">$C390/50064</A>      JOB $84: MOTON_DV
  |   <A HREF="RO81C393.HTM">$C393/50067</A>      JOB $86: MOTOFF_DV
  |   <A HREF="RO81C396.HTM">$C396/50070</A>      JOB $88: MOTONI_DV
  |   <A HREF="RO81C3A9.HTM">$C3A9/50089</A>      JOB $8a: MOTOFFI_DV
  |   <A HREF="RO81C3AF.HTM">$C3AF/50095</A>      JOB $8c: SEEK_DV
  |   <A HREF="RO81C3BB.HTM">$C3BB/50107</A>      JOB $8e: FORMAT_DV
  |   <A HREF="RO81C3D6.HTM">$C3D6/50134</A>      Spur formatieren
  |   <A HREF="RO81C546.HTM">$C546/50502</A>      LED-Routinen des Controller-Programms
  |   <A HREF="RO81C56A.HTM">$C56A/50538</A>      JOB $9c: SIDE_DV
  |   <A HREF="RO81C589.HTM">$C589/50569</A>      JOB $9e: BUFMOVE_DV
  |   <A HREF="RO81C5AC.HTM">$C5AC/50604</A>      JOB $a2: TRKWRT_DV
  |   <A HREF="RO81C5AF.HTM">$C5AF/50607</A>      Patches
  |   <A HREF="RO81C600.HTM">$C600/50688</A>      Cachepuffer auf Diskette schreiben
  |   <A HREF="RO81C6D7.HTM">$C6D7/50903</A>      JOBs $92, $a8: DISKIN_DV, PSEEK_DV
  |   <A HREF="RO81C700.HTM">$C700/50944</A>      JOB $a6: SP_WRITE
  |   <A HREF="RO81C800.HTM">$C800/51200</A>      JOB $a4: SP_READ
  |   <A HREF="RO81C900.HTM">$C900/51456</A>      JOBs $80, $90: READ_DV, WRITE_DV
  |   <A HREF="RO81C9E1.HTM">$C9E1/51681</A>      Job $a0: WRTVER_DV
  |   <A HREF="RO81CA00.HTM">$CA00/51712</A>      Spur mit Cachedaten vergleichen
  |   <A HREF="RO81CADC.HTM">$CADC/51932</A>      Verify-Error ausgeben
  |   <A HREF="RO81CAE4.HTM">$CAE4/51940</A>      JOB $b8: SEEKPHD_DV
  |   <A HREF="RO81CB0F.HTM">$CB0F/51983</A>      JOB $c0: RESTORE_DV
  |   <A HREF="RO81CB26.HTM">$CB26/52006</A>      JOBs $d0, $e0: JUMPC_DV, EXBUF_DV: Programm im Jobpuffer ausfuehren
  |   <A HREF="RO81CB35.HTM">$CB35/52021</A>      JOB $f0: FORMATDK_DV
  |   <A HREF="RO81CB76.HTM">$CB76/52086</A>      JOB $b6: DETWP_DV
  |   <A HREF="RO81CB85.HTM">$CB85/52101</A>      Job-Fehlermeldungen
  |   <A HREF="RO81CB8D.HTM">$CB8D/52109</A>      Prueft, ob Sektor in Cachepuffer passt, Cachezeiger setzen
  |   <A HREF="RO81CB9F.HTM">$CB9F/52127</A>      Timer setzen und starten
  |   <A HREF="RO81CBB1.HTM">$CBB1/52145</A>      Laufwerksmotor ein-/ausschalten
  |   <A HREF="RO81CBC3.HTM">$CBC3/52163</A>      Drive LED ein-/ausschalten
  |   <A HREF="RO81CBD5.HTM">$CBD5/52181</A>      Warten ... .  .   .zzz . .z ..
  |   <A HREF="RO81CBEC.HTM">$CBEC/52204</A>      Auf Controller-Ready warten
  |   <A HREF="RO81CBF4.HTM">$CBF4/52212</A>      Kommandobyte in Controller schreiben
  |   <A HREF="RO81CD00.HTM">$CD00/52480</A>      Blockheader lesen
  |   <A HREF="RO81CD3F.HTM">$CD3F/52543</A>      Controller-Status pruefen
  |   <A HREF="RO81CD63.HTM">$CD63/52579</A>      Wenn der Motor aus war, Motor einschalten und Verzoegerungszeit einstellen
  |   <A HREF="RO81CD7B.HTM">$CD7B/52603</A>      Anlaufvorgang ueberwachen
  |   <A HREF="RO81CDBC.HTM">$CDBC/52668</A>      Abfragen, ob Diskette eingelegt ist
  |   <A HREF="RO81CDCC.HTM">$CDCC/52684</A>      Jobauftrag beenden, alle Jobs nochmal pruefen
  |   <A HREF="RO81CDE2.HTM">$CDE2/52706</A>      Ruecksprung von Jobroutine, den selben Job nochmal pruefen
  |   <A HREF="RO81CE00.HTM">$CE00/52736</A>      Hauptsteuerroutine des Controllers
  |   <A HREF="RO81CE71.HTM">$CE71/52849</A>      Schrittmotor ansteuern
  |   <A HREF="RO81CEA4.HTM">$CEA4/52900</A>      Daten zwischen Cache und Puffer transferieren
  |   <A HREF="RO81CEDC.HTM">$CEDC/52956</A>      JTRANS_TS: logisches in physikalisches Format umwandeln
  |   <A HREF="RO81CF51.HTM">$CF51/53073</A>      Schreiben/Lesen mit Cache-Daten
  |   <A HREF="RO81CFA6.HTM">$CFA6/53158</A>      Blockheader lesen
  |   <A HREF="RO81CFB7.HTM">$CFB7/53175</A>      Copy-Zeiger auf Cachepuffer-Anfang setzen
  |   <A HREF="RO81CFC0.HTM">$CFC0/53184</A>      Seite auswaehlen
  |   <A HREF="RO81CFD1.HTM">$CFD1/53201</A>      Controller initialisieren
  |   <A HREF="RO81CFE3.HTM">$CFE3/53219</A>      Precompensation ein/ausschalten
  |   <A HREF="RO81D00D.HTM">$D00D/53261</A>      Daten vom Puffer in den Cache kopieren
  |   <A HREF="RO81D549.HTM">$D549/54601</A>      Daten vom Cache in den Puffer kopieren
  |   <A HREF="RO81DA63.HTM">$DA63/55907</A>      CRC-Pruefsumme des Blockheaders testen
  |   <A HREF="RO81DAFD.HTM">$DAFD/56061</A>      IRQ-Routine
  |   <A HREF="RO81DBC7.HTM">$DBC7/56263</A>      Patches
  |   <A HREF="RO81FF00.HTM">$FF00/65280</A>      Sprungvektoren
  |   <A HREF="RO81FF75.HTM">$FF75/65397</A>      Tabelle der DOS-Funktionen
  |
  +------------------------------------------------------------------------

</PRE></BODY></HTML>
